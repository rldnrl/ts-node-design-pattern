# 팩토리 패턴
## 장점
- 특정 구현으로부터 객체의 생성을 분리할 수 있다. 예를 들어 실행 시 생성되는 객체를 결정할 수 있다.
- 클래스보다 훨씬 작은 "면"을 노출할 수 있게 한다. 클래스는 확장되거나 조작될 수 있지만 팩토리는 함수일 뿐이기 때문에 사용자에게 더 적은 유연선을 제공하여 강력하고 이해하기 쉽다.
- 클로저를 활용하여 캡슐화를 강제하는데 사용될 수 있다.

<br />

## 객체 생성과 구현의 분리
팩토리는 새 인스턴스 생성을 감싸서 객체 생성시 더 많은 유연성과 제어를 제공한다. 팩토리 내에는 new 연산자를 사용하여 클래스의 새 인스턴스를 만들거나, 클로저를 활용하여 상태를 기억하는 객체 리터럴을 동적으로 작성하거나, 특정 조건에 따라 다른 유형의 객체를 반환하도록 할 수도 있다. 팩토리를 사용하는 사람은 인스턴스 생성이 수행되는 방식에 대해서 전혀 알 수 없다. 사실 new를 사용하면 객체를 생성하는 특정 방법에 코드를 바인딩하는 반면, 팩토리를 사용하면 큰 노력 없이 더 많은 유연성을 가질 수 있다.

```ts
function createImage (name: string) {
  return new Image(name)
}

const image = create('photo.jpg')
```

이미지 형식마다 하나의 클래스를 지원하기 위해서 Image 클래스를 더 작은 클래스로 분할한다고 해보자.

```ts
function createImage (name: string) {
  if (name.match(/\.jpg?g$/)) {
    return new ImageJpeg(name)
  } else if (name.match(/\.gif?g$/)) {
    return new ImageGif(name)
  } else if (name.match(/\.png?g$/)) {
    return new ImagePng(name)
  } else {
    throw new Error("Unsupported Format")
  }
}
```

팩토리는 또한 클래스를 숨겨, 멋대로 확장하거나 수정하는 것을 막아준다. 팩토리만 사용함으로써 클래스를 비공개로 유지할 수 있다.

<br />

## 캡슐화를 강제할 수 있는 메커니즘
팩토리는 클로저 덕분에 캡슐화 메커니즘으로 사용될 수 있다. 캡슐화는 외부 코드가 컴포넌트의 내부 핵심에 직접 접근하여 조작하는 것을 방지하기 위해 접근을 제어하는 것을 의미한다. 컴포넌트와의 상호작용은 오직 공용 인터페이스를 통해서만 가능하다. 컴포넌트의 상세 구현의 변경으로부터 외부 코드를 분리시킬 수 있다.